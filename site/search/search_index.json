{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"Get Started Reference"},{"location":"#fast","title":"\u26a1Fast","text":"<p>Parallelizer uses a bindable-based approach that is ~2x faster than its SharedTable counterpart.</p>"},{"location":"#lightweight","title":"\ud83e\udeb6Lightweight","text":"<p>With no added dependencies, Parallelizer prioritizes simplicity and efficiency.</p>"},{"location":"#performant","title":"\u2728Performant","text":"<p>Designed with minimal footprint, Parallelizer uses only the necessary resources, without creating any additional overhead.</p>"},{"location":"api/","title":"Parallelizer","text":"<p>Contains constructor methods to instantiate classes</p>"},{"location":"api/#properties","title":"Properties","text":""},{"location":"api/#functions","title":"Functions","text":""},{"location":"api/#createthread","title":"<code>CreateThread</code>","text":"<p>Note</p> <p>You may only use this function in the Job Script!</p> <p>Creates a new message bind to the actor, which has a middleware for handling <code>batchSize</code>. The return value of the callback will be sent via the bindable event to be put back together by the Job Scheduler</p> <p>Parameters</p> <ul> <li>actor: <code>Actor</code> The actor to bind the message </li> <li>callback: <code>(threadId: number, instructionTable: SharedTable) -&gt; any</code> A callback with threadId as the index order of the thread and a SharedTable for constants, or can be used as a shared memory/resource</li> </ul> <p>Returns</p> <ul> <li><code>void</code></li> </ul>"},{"location":"api/#createjobscheduler","title":"<code>CreateJobScheduler</code>","text":"<p>Create a new population of actors alongside the Job Script and creates a new Job Scheduler</p> <p>Parameters</p> <ul> <li>jobScript: <code>Script | LocalScript</code> The script that will be cloned across the actors</li> <li>actorCount: <code>number</code> How many actors will be created, ideally should be a power of 2. Refer to Multithreading Best Practices to determine the right number of actors</li> <li>actorStorage: <code>Instance</code> Where to store the actors along with the Job Scripts once created.</li> </ul> <p>Returns</p> <ul> <li><code>Job Scheduler</code></li> </ul>"},{"location":"api/#createinstructiondata","title":"<code>CreateInstructionData</code>","text":"<p>Creates a new container to store the SharedTable version of your data</p> <p>Parameters</p> <ul> <li>data: <code>InstructionTableData</code> The data to store as a SharedTable, only certain types are allowed</li> </ul> <p>Returns</p> <ul> <li><code>InstructionData</code></li> </ul>"},{"location":"api/job-scheduler/","title":"Job Scheduler","text":"<p>Manages handling of the job scripts/workers and thread dispatches</p>"},{"location":"api/job-scheduler/#properties","title":"Properties","text":""},{"location":"api/job-scheduler/#actors","title":"<code>Actors</code>","text":"<ul> <li><code>{Actor}</code> A list of actors, each with its own job script</li> </ul>"},{"location":"api/job-scheduler/#packetbindable","title":"<code>PacketBindable</code>","text":"<ul> <li><code>BindableEvent</code> The bindable event to serve as the parallel bridge</li> </ul>"},{"location":"api/job-scheduler/#methods","title":"Methods","text":""},{"location":"api/job-scheduler/#dispatchasync","title":"<code>DispatchAsync</code>","text":"<p>Note</p> <p>This method is asynchronous!</p> <p>Danger</p> <p>You cannot have more than 1 dispatches going on at once, as it would collide with the other dispatch</p> <p>Defers the dispatch that will go through all actors, if the threadCount is bigger than the actorCount, then it will cycle back. A connection to the bindable is made that will piece together the packets into one table, which will be sent to the callback</p> <p>Parameters</p> <ul> <li>threadName: <code>string</code> The unique string identifier bound to the actors by <code>Parallelizer.CreateThread</code> </li> <li>threadCount: <code>number</code> The number of threads to be dispatched across the actors. Usually, this is the number of data you want to compute. For example, for a 100x100 renderer, the <code>threadCount</code> will be <code>100*100</code></li> <li>batchSize: <code>number</code> How many threads should one actor process</li> <li>callback: <code>(result: {any}) -&gt; void</code> The callback to be called after all workers has finished sending their work</li> <li>instData: <code>InstructionData</code> The instruction data to be sent to the actors</li> </ul> <p>Returns</p> <ul> <li><code>thread</code></li> </ul>"},{"location":"api/job-scheduler/#dispatchequallyasync","title":"<code>DispatchEquallyAsync</code>","text":"<p>Note</p> <p>This method is asynchronous!</p> <p>Danger</p> <p>You cannot have more than 1 dispatches going on at once, as it would collide with the other dispatch</p> <p>A proxy to <code>DispatchAsync</code>, batchSize will be calculated automatically</p> <p>Parameters</p> <ul> <li>threadName: <code>string</code> The unique string identifier bound to the actors by <code>Parallelizer.CreateThread</code> </li> <li>threadCount: <code>number</code> The number of threads to be dispatched across the actors. Usually, this is the number of data you want to compute. For example, for a 100x100 renderer, the <code>threadCount</code> will be <code>100*100</code></li> <li>callback: <code>(result: {any}) -&gt; void</code> The callback to be called after all workers has finished sending their work</li> <li>instData: <code>InstructionData</code> The instruction data to be sent to the actors</li> </ul> <p>Returns</p> <ul> <li><code>void</code></li> </ul>"},{"location":"api/job-scheduler/#destroy","title":"<code>Destroy</code>","text":"<p>Disposes the actors and bindables, and destroys the Job Scheduler</p> <p>Parameters</p> <p>Returns</p> <ul> <li><code>void</code></li> </ul>"},{"location":"api/types/","title":"Types","text":""},{"location":"api/types/#allowedinstructionvalues","title":"AllowedInstructionValues","text":"<ul> <li><code>Vector2 | Vector3 | CFrame | Color3 | UDim | UDim2 | number | boolean | string</code></li> </ul>"},{"location":"api/types/#instructiontabledata","title":"InstructionTableData","text":"<ul> <li><code>{[number]: AllowedInstructionValues | InstructionTableData}</code></li> </ul>"},{"location":"guides/getting-started/","title":"Getting Started","text":"<p>Danger</p> <p>Messing with generally all parallel code is prone to crashes. This is due to a few reasons, the most common I've encountered being errors. Since the Job Script is cloned across the actors, if one errors, most likely the other will - which causes a chain reaction that will flood your output and potentially crash your studio.</p> <p>To avoid loss of progress, you can create a backup before running your script, or publish the place to enable auto-saving</p>"},{"location":"guides/getting-started/#prerequisites","title":"Prerequisites","text":"<ul> <li>Basic Luau Knowledge</li> <li>We also recommend having a base understanding parallel computing concepts, such as threads and work partitioning</li> </ul>"},{"location":"guides/getting-started/#what-could-i-use-this-for","title":"What could I use this for?","text":"<p>One of the main goal of Parallel Processing is to reduce the strain and lag from the intense computations that you may use. Here are some examples use cases:</p> <ul> <li>Terrain Generation</li> <li>Bullet Raycast Computations</li> <li>Enemy AI</li> </ul>"},{"location":"guides/getting-started/#installation","title":"Installation","text":"<p>If you haven't already installed the module, refer to Installation</p>"},{"location":"guides/getting-started/#setup","title":"Setup","text":"<p>For the sake of simplicity, place the module in <code>ReplicatedStorage</code> for easy access.</p> <p>Before we do anything we first need to require the module <pre><code>local Parallelizer = require(game.ReplicatedStorage.Parallelizer)\n</code></pre></p>"},{"location":"guides/getting-started/#job-scheduler","title":"Job Scheduler","text":"<p>Next, we can create a Job Scheduler to manage the workers, this allows you to communicate between the serial main thread to the many parallel threads.</p> <p>To create a new Job Scheduler, you can use <code>Parallelizer.CreateJobScheduler</code>, which takes in 3 arguments in order:</p> <ol> <li>Job Script/Worker Script -&gt;     This is the script that will run one or more tasks in parallel</li> <li>Actor Count -&gt;     This is how many actors will be created, ideally the actor count should be a power of 2. You can refer to the Multithreading Best Practices to determine the right number of actors needed. Or you can just do 256 or 64 since those usually are the magic numbers</li> <li>Actor Storage -&gt;     Where should the actors be stored. If the Worker Script is a LocalScript, you must store them where they can run (such as <code>ReplicatedStorage</code>). Or if the Worker Script is a Server Script, you can store them in ServerScriptService, ServerStorage, etc..</li> </ol> <p>In this example, we'll use 64 actors and store them below the script <pre><code>local Parallelizer = require(game.ReplicatedStorage.Parallelizer)\nlocal JobScheduler = Parallelizer.CreateJobScheduler(script.Job, 64, script)\n</code></pre></p> <p>Note</p> <p>If you're targeting 4-core systems, that doesn't mean you should use just 4 actors. 64 actors and more is reasonable since it allows it to distribute the work based on the capability of the underlying hardware</p>"},{"location":"guides/getting-started/#job-script","title":"Job Script","text":"<p>Now, since the Job Scheduler needs a Job Script, add a script under the master script. Optionally, you can disable the Job Script.</p> <p>In the Job Script, we will get the active actor instance and require the module once again <pre><code>local Actor = script:GetActor()\n\n-- A safeguard to ensure it doesn't run without an actor\nif not Actor then\n    return\nend\n\nlocal Parallelizer = require(game.ReplicatedStorage.Parallelizer)\n</code></pre> Next, in the Job Script, we can make a thread dedicated to a specific task to be run in Parallel</p> <p>To create a new thread, you can use <code>Parallelizer.CreateThread</code>, which takes in 3 arguments in order:</p> <ol> <li>Actor -&gt; The actor, duh</li> <li>Thread Name -&gt; An unique string identifier for the specific task you want to do</li> <li>Callback -&gt; The callback function to be called whenever the Job Scheduler dispatched the thread, it has 2 arguments:<ol> <li>Thread Id -&gt; A numerical identifier/index that goes in increasing order within the range <code>[1, threadCount]</code>. This is crucial for Parallel Tasks since it allows you to minimize the data that you need to send to the Job Script</li> <li>Instruction Table -&gt; A SharedTable sent from the Job Scheduler's fourth argument, this is mostly used for constants and setting values. However you can also use this as a shared memory/resource</li> </ol> </li> </ol> <p>Here, we'll create a thread dedicated to calculating the nth root of thread id <pre><code>-- ... trimmed\nlocal Parallelizer = require(game.ReplicatedStorage.Parallelizer)\n\nParallelizer.CreateThread(Actor, 'CalculateNthRoot', function(id, inst)\n    local nth = inst[1]\n\n    -- Example: nth of 2 is equal to square root, and nth of 3 is equal to cube root \n    return id^(1/nth)\nend)\n</code></pre></p>"},{"location":"guides/getting-started/#dispatching","title":"Dispatching","text":"<p>Now that we have the Job Script set up, we can go back to the master script to dispatch the thread.</p> <p>There are 2 ways to dispatch threads: <code>:DispatchAsync</code> and <code>:DispatchEquallyAsync</code>. Both of which has similar parameters, the difference being <code>batchSize</code> will be calculated automatically when you use <code>DispatchEquallyAsync</code>. For example if the <code>batchSize</code> is 2, then each actor will have to do 2 of the same thread at a time.</p> <p>The Dispatch methods also has an optional parameter, that is the instruction data to be passed to parallel. To do so you need to create a new <code>InstructionData</code> object using <code>Parallelizer.CreateInstructionData</code>, that only has 1 argument, which is the data you want to send.</p> <p>For simplicity, we will use <code>DispatchEquallyAsync</code> <pre><code>local Parallelizer = require(game.ReplicatedStorage.Parallelizer)\nlocal JobScheduler = Parallelizer.CreateJobScheduler(script.Job, 64, script)\n\nlocal RootInstruction = Parallelizer.CreateInstructionData({2}) -- the 2th root (square root)\n\n-- Get the nth root from 1 to 1024\nJobScheduler:DispatchEquallyAsync('CalculateNthRoot', 1024, function(result)\n    print(result) -- The calculated roots up to 1024\nend)\n\nprint('This will run before the dispatch has finished!')\n</code></pre></p> <p>Warning</p> <p>Both of the Dispatch methods are asynchronous, meaning the succeeding code after dispatch will run even if the dispatch hasn't finished</p> <p>Tip</p> <p>You can destroy the Job Scheduler to clean up memory when it's no longer used. This is achieved by calling the <code>:Destroy()</code> method, after which will dispose the actors, and the bindable event</p> <p>Congratulations, you've reached the end! Now you can use this newfound knowledge and create some blazingly fast parallel computations!</p>"},{"location":"guides/installation/","title":"Installation","text":""},{"location":"guides/installation/#roblox","title":"Roblox","text":"<ol> <li>Go to the Creator Store Page</li> <li>Click Get Model</li> <li>Insert the module through the toolbox</li> </ol>"}]}